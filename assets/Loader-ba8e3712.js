import{b as B,u as Be,_ as Ge,K as nt,V as j,a1 as me,a0 as he,a as I,am as ot,an as De,ao as at,a6 as Ze,ap as Ve,aq as ue,ar as de,as as it,at as st}from"./react-three-fiber.esm-eee518fd.js";import{r as h,c as rt,a as Se,j as ke}from"./index-5d434cdc.js";const Me=new j,Ye=new j,ct=new j,Xe=new I;function lt(a,o,r){const e=Me.setFromMatrixPosition(a.matrixWorld);e.project(o);const P=r.width/2,E=r.height/2;return[e.x*P+P,-(e.y*E)+E]}function ut(a,o){const r=Me.setFromMatrixPosition(a.matrixWorld),e=Ye.setFromMatrixPosition(o.matrixWorld),P=r.sub(e),E=o.getWorldDirection(ct);return P.angleTo(E)>Math.PI/2}function dt(a,o,r,e){const P=Me.setFromMatrixPosition(a.matrixWorld),E=P.clone();E.project(o),Xe.set(E.x,E.y),r.setFromCamera(Xe,o);const w=r.intersectObjects(e,!0);if(w.length){const c=w[0].distance;return P.distanceTo(r.ray.origin)<c}return!0}function mt(a,o){if(o instanceof me)return o.zoom;if(o instanceof he){const r=Me.setFromMatrixPosition(a.matrixWorld),e=Ye.setFromMatrixPosition(o.matrixWorld),P=o.fov*Math.PI/180,E=r.distanceTo(e);return 1/(2*Math.tan(P/2)*E)}else return 1}function ht(a,o,r){if(o instanceof he||o instanceof me){const e=Me.setFromMatrixPosition(a.matrixWorld),P=Ye.setFromMatrixPosition(o.matrixWorld),E=e.distanceTo(P),w=(r[1]-r[0])/(o.far-o.near),c=r[1]-w*o.far;return Math.round(w*E+c)}}const He=a=>Math.abs(a)<1e-10?0:a;function qe(a,o,r=""){let e="matrix3d(";for(let P=0;P!==16;P++)e+=He(o[P]*a.elements[P])+(P!==15?",":")");return r+e}const ft=(a=>o=>qe(o,a))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),pt=(a=>(o,r)=>qe(o,a(r),"translate(-50%,-50%)"))(a=>[1/a,1/a,1/a,1,-1/a,-1/a,-1/a,-1,1/a,1/a,1/a,1,1,1,1,1]);function bt(a){return a&&typeof a=="object"&&"current"in a}const gt=h.forwardRef(({children:a,eps:o=.001,style:r,className:e,prepend:P,center:E,fullscreen:w,portal:c,distanceFactor:d,sprite:ae=!1,transform:l=!1,occlude:f,onOcclude:S,castShadow:F,receiveShadow:_,material:z,geometry:R,zIndexRange:A=[16777271,0],calculatePosition:N=lt,as:k="div",wrapperClass:L,pointerEvents:g="auto",...u},G)=>{const{gl:D,camera:y,scene:m,size:v,raycaster:Ne,events:ie,viewport:fe}=B(),[x]=h.useState(()=>document.createElement(k)),se=h.useRef(),T=h.useRef(null),V=h.useRef(0),q=h.useRef([0,0]),Q=h.useRef(null),re=h.useRef(null),W=(c==null?void 0:c.current)||ie.connected||D.domElement.parentNode,H=h.useRef(null),ce=h.useRef(!1),te=h.useMemo(()=>f&&f!=="blending"||Array.isArray(f)&&f.length&&bt(f[0]),[f]);h.useLayoutEffect(()=>{const O=D.domElement;f&&f==="blending"?(O.style.zIndex=`${Math.floor(A[0]/2)}`,O.style.position="absolute",O.style.pointerEvents="none"):(O.style.zIndex=null,O.style.position=null,O.style.pointerEvents=null)},[f]),h.useLayoutEffect(()=>{if(T.current){const O=se.current=rt(x);if(m.updateMatrixWorld(),l)x.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const b=N(T.current,y,v);x.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${b[0]}px,${b[1]}px,0);transform-origin:0 0;`}return W&&(P?W.prepend(x):W.appendChild(x)),()=>{W&&W.removeChild(x),O.unmount()}}},[W,l]),h.useLayoutEffect(()=>{L&&(x.className=L)},[L]);const xe=h.useMemo(()=>l?{position:"absolute",top:0,left:0,width:v.width,height:v.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:E?"translate3d(-50%,-50%,0)":"none",...w&&{top:-v.height/2,left:-v.width/2,width:v.width,height:v.height},...r},[r,E,w,v,l]),Ce=h.useMemo(()=>({position:"absolute",pointerEvents:g}),[g]);h.useLayoutEffect(()=>{if(ce.current=!1,l){var O;(O=se.current)==null||O.render(h.createElement("div",{ref:Q,style:xe},h.createElement("div",{ref:re,style:Ce},h.createElement("div",{ref:G,className:e,style:r,children:a}))))}else{var b;(b=se.current)==null||b.render(h.createElement("div",{ref:G,style:xe,className:e,children:a}))}});const J=h.useRef(!0);Be(O=>{if(T.current){y.updateMatrixWorld(),T.current.updateWorldMatrix(!0,!1);const b=l?q.current:N(T.current,y,v);if(l||Math.abs(V.current-y.zoom)>o||Math.abs(q.current[0]-b[0])>o||Math.abs(q.current[1]-b[1])>o){const U=ut(T.current,y);let C=!1;te&&(Array.isArray(f)?C=f.map(Z=>Z.current):f!=="blending"&&(C=[m]));const ne=J.current;if(C){const Z=dt(T.current,y,Ne,C);J.current=Z&&!U}else J.current=!U;ne!==J.current&&(S?S(!J.current):x.style.display=J.current?"block":"none");const le=Math.floor(A[0]/2),Te=f?te?[A[0],le]:[le-1,0]:A;if(x.style.zIndex=`${ht(T.current,y,Te)}`,l){const[Z,pe]=[v.width/2,v.height/2],be=y.projectionMatrix.elements[5]*pe,{isOrthographicCamera:Oe,top:je,left:ge,bottom:oe,right:Ie}=y,_e=ft(y.matrixWorldInverse),Ae=Oe?`scale(${be})translate(${He(-(Ie+ge)/2)}px,${He((je+oe)/2)}px)`:`translateZ(${be}px)`;let Y=T.current.matrixWorld;ae&&(Y=y.matrixWorldInverse.clone().transpose().copyPosition(Y).scale(T.current.scale),Y.elements[3]=Y.elements[7]=Y.elements[11]=0,Y.elements[15]=1),x.style.width=v.width+"px",x.style.height=v.height+"px",x.style.perspective=Oe?"":`${be}px`,Q.current&&re.current&&(Q.current.style.transform=`${Ae}${_e}translate(${Z}px,${pe}px)`,re.current.style.transform=pt(Y,1/((d||10)/400)))}else{const Z=d===void 0?1:mt(T.current,y)*d;x.style.transform=`translate3d(${b[0]}px,${b[1]}px,0) scale(${Z})`}q.current=b,V.current=y.zoom}}if(!te&&H.current&&!ce.current)if(l){if(Q.current){const b=Q.current.children[0];if(b!=null&&b.clientWidth&&b!=null&&b.clientHeight){const{isOrthographicCamera:U}=y;if(U||R)u.scale&&(Array.isArray(u.scale)?u.scale instanceof j?H.current.scale.copy(u.scale.clone().divideScalar(1)):H.current.scale.set(1/u.scale[0],1/u.scale[1],1/u.scale[2]):H.current.scale.setScalar(1/u.scale));else{const C=(d||10)/400,ne=b.clientWidth*C,le=b.clientHeight*C;H.current.scale.set(ne,le,1)}ce.current=!0}}}else{const b=x.children[0];if(b!=null&&b.clientWidth&&b!=null&&b.clientHeight){const U=1/fe.factor,C=b.clientWidth*U,ne=b.clientHeight*U;H.current.scale.set(C,ne,1),ce.current=!0}H.current.lookAt(O.camera.position)}});const we=h.useMemo(()=>({vertexShader:l?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[l]);return h.createElement("group",Ge({},u,{ref:T}),f&&!te&&h.createElement("mesh",{castShadow:F,receiveShadow:_,ref:H},R||h.createElement("planeGeometry",null),z||h.createElement("shaderMaterial",{side:nt,vertexShader:we.vertexShader,fragmentShader:we.fragmentShader})))});let ve=0;const yt=ot(a=>(De.onStart=(o,r,e)=>{a({active:!0,item:o,loaded:r,total:e,progress:(r-ve)/(e-ve)*100})},De.onLoad=()=>{a({active:!1})},De.onError=o=>a(r=>({errors:[...r.errors,o]})),De.onProgress=(o,r,e)=>{r===e&&(ve=e),a({active:!0,item:o,loaded:r,total:e,progress:(r-ve)/(e-ve)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));var Pt=Object.defineProperty,Et=(a,o,r)=>o in a?Pt(a,o,{enumerable:!0,configurable:!0,writable:!0,value:r}):a[o]=r,i=(a,o,r)=>(Et(a,typeof o!="symbol"?o+"":o,r),r);const Re=new it,Ke=new st,vt=Math.cos(70*(Math.PI/180)),$e=(a,o)=>(a%o+o)%o;let Mt=class extends at{constructor(o,r){super(),i(this,"object"),i(this,"domElement"),i(this,"enabled",!0),i(this,"target",new j),i(this,"minDistance",0),i(this,"maxDistance",1/0),i(this,"minZoom",0),i(this,"maxZoom",1/0),i(this,"minPolarAngle",0),i(this,"maxPolarAngle",Math.PI),i(this,"minAzimuthAngle",-1/0),i(this,"maxAzimuthAngle",1/0),i(this,"enableDamping",!1),i(this,"dampingFactor",.05),i(this,"enableZoom",!0),i(this,"zoomSpeed",1),i(this,"enableRotate",!0),i(this,"rotateSpeed",1),i(this,"enablePan",!0),i(this,"panSpeed",1),i(this,"screenSpacePanning",!0),i(this,"keyPanSpeed",7),i(this,"zoomToCursor",!1),i(this,"autoRotate",!1),i(this,"autoRotateSpeed",2),i(this,"reverseOrbit",!1),i(this,"reverseHorizontalOrbit",!1),i(this,"reverseVerticalOrbit",!1),i(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),i(this,"mouseButtons",{LEFT:ue.ROTATE,MIDDLE:ue.DOLLY,RIGHT:ue.PAN}),i(this,"touches",{ONE:de.ROTATE,TWO:de.DOLLY_PAN}),i(this,"target0"),i(this,"position0"),i(this,"zoom0"),i(this,"_domElementKeyEvents",null),i(this,"getPolarAngle"),i(this,"getAzimuthalAngle"),i(this,"setPolarAngle"),i(this,"setAzimuthalAngle"),i(this,"getDistance"),i(this,"listenToKeyEvents"),i(this,"stopListenToKeyEvents"),i(this,"saveState"),i(this,"reset"),i(this,"update"),i(this,"connect"),i(this,"dispose"),this.object=o,this.domElement=r,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>l.phi,this.getAzimuthalAngle=()=>l.theta,this.setPolarAngle=t=>{let n=$e(t,2*Math.PI),s=l.phi;s<0&&(s+=2*Math.PI),n<0&&(n+=2*Math.PI);let p=Math.abs(n-s);2*Math.PI-p<p&&(n<s?n+=2*Math.PI:s+=2*Math.PI),f.phi=n-s,e.update()},this.setAzimuthalAngle=t=>{let n=$e(t,2*Math.PI),s=l.theta;s<0&&(s+=2*Math.PI),n<0&&(n+=2*Math.PI);let p=Math.abs(n-s);2*Math.PI-p<p&&(n<s?n+=2*Math.PI:s+=2*Math.PI),f.theta=n-s,e.update()},this.getDistance=()=>e.object.position.distanceTo(e.target),this.listenToKeyEvents=t=>{t.addEventListener("keydown",Y),this._domElementKeyEvents=t},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Y),this._domElementKeyEvents=null},this.saveState=()=>{e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=()=>{e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(P),e.update(),d=c.NONE},this.update=(()=>{const t=new j,n=new j(0,1,0),s=new Ze().setFromUnitVectors(o.up,n),p=s.clone().invert(),M=new j,X=new Ze,ee=2*Math.PI;return function(){const Ue=e.object.position;s.setFromUnitVectors(o.up,n),p.copy(s).invert(),t.copy(Ue).sub(e.target),t.applyQuaternion(s),l.setFromVector3(t),e.autoRotate&&d===c.NONE&&fe(Ne()),e.enableDamping?(l.theta+=f.theta*e.dampingFactor,l.phi+=f.phi*e.dampingFactor):(l.theta+=f.theta,l.phi+=f.phi);let K=e.minAzimuthAngle,$=e.maxAzimuthAngle;isFinite(K)&&isFinite($)&&(K<-Math.PI?K+=ee:K>Math.PI&&(K-=ee),$<-Math.PI?$+=ee:$>Math.PI&&($-=ee),K<=$?l.theta=Math.max(K,Math.min($,l.theta)):l.theta=l.theta>(K+$)/2?Math.max(K,l.theta):Math.min($,l.theta)),l.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,l.phi)),l.makeSafe(),e.enableDamping===!0?e.target.addScaledVector(F,e.dampingFactor):e.target.add(F),e.zoomToCursor&&y||e.object.isOrthographicCamera?l.radius=W(l.radius):l.radius=W(l.radius*S),t.setFromSpherical(l),t.applyQuaternion(p),Ue.copy(e.target).add(t),e.object.matrixAutoUpdate||e.object.updateMatrix(),e.object.lookAt(e.target),e.enableDamping===!0?(f.theta*=1-e.dampingFactor,f.phi*=1-e.dampingFactor,F.multiplyScalar(1-e.dampingFactor)):(f.set(0,0,0),F.set(0,0,0));let ye=!1;if(e.zoomToCursor&&y){let Pe=null;if(e.object instanceof he&&e.object.isPerspectiveCamera){const Ee=t.length();Pe=W(Ee*S);const Le=Ee-Pe;e.object.position.addScaledVector(G,Le),e.object.updateMatrixWorld()}else if(e.object.isOrthographicCamera){const Ee=new j(D.x,D.y,0);Ee.unproject(e.object),e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/S)),e.object.updateProjectionMatrix(),ye=!0;const Le=new j(D.x,D.y,0);Le.unproject(e.object),e.object.position.sub(Le).add(Ee),e.object.updateMatrixWorld(),Pe=t.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),e.zoomToCursor=!1;Pe!==null&&(e.screenSpacePanning?e.target.set(0,0,-1).transformDirection(e.object.matrix).multiplyScalar(Pe).add(e.object.position):(Re.origin.copy(e.object.position),Re.direction.set(0,0,-1).transformDirection(e.object.matrix),Math.abs(e.object.up.dot(Re.direction))<vt?o.lookAt(e.target):(Ke.setFromNormalAndCoplanarPoint(e.object.up,e.target),Re.intersectPlane(Ke,e.target))))}else e.object instanceof me&&e.object.isOrthographicCamera&&(ye=S!==1,ye&&(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/S)),e.object.updateProjectionMatrix()));return S=1,y=!1,ye||M.distanceToSquared(e.object.position)>ae||8*(1-X.dot(e.object.quaternion))>ae?(e.dispatchEvent(P),M.copy(e.object.position),X.copy(e.object.quaternion),ye=!1,!0):!1}})(),this.connect=t=>{t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),e.domElement=t,e.domElement.style.touchAction="none",e.domElement.addEventListener("contextmenu",Fe),e.domElement.addEventListener("pointerdown",je),e.domElement.addEventListener("pointercancel",oe),e.domElement.addEventListener("wheel",Ae)},this.dispose=()=>{var t,n,s,p,M,X;e.domElement&&(e.domElement.style.touchAction="auto"),(t=e.domElement)==null||t.removeEventListener("contextmenu",Fe),(n=e.domElement)==null||n.removeEventListener("pointerdown",je),(s=e.domElement)==null||s.removeEventListener("pointercancel",oe),(p=e.domElement)==null||p.removeEventListener("wheel",Ae),(M=e.domElement)==null||M.ownerDocument.removeEventListener("pointermove",ge),(X=e.domElement)==null||X.ownerDocument.removeEventListener("pointerup",oe),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",Y)};const e=this,P={type:"change"},E={type:"start"},w={type:"end"},c={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let d=c.NONE;const ae=1e-6,l=new Ve,f=new Ve;let S=1;const F=new j,_=new I,z=new I,R=new I,A=new I,N=new I,k=new I,L=new I,g=new I,u=new I,G=new j,D=new I;let y=!1;const m=[],v={};function Ne(){return 2*Math.PI/60/60*e.autoRotateSpeed}function ie(){return Math.pow(.95,e.zoomSpeed)}function fe(t){e.reverseOrbit||e.reverseHorizontalOrbit?f.theta+=t:f.theta-=t}function x(t){e.reverseOrbit||e.reverseVerticalOrbit?f.phi+=t:f.phi-=t}const se=(()=>{const t=new j;return function(s,p){t.setFromMatrixColumn(p,0),t.multiplyScalar(-s),F.add(t)}})(),T=(()=>{const t=new j;return function(s,p){e.screenSpacePanning===!0?t.setFromMatrixColumn(p,1):(t.setFromMatrixColumn(p,0),t.crossVectors(e.object.up,t)),t.multiplyScalar(s),F.add(t)}})(),V=(()=>{const t=new j;return function(s,p){const M=e.domElement;if(M&&e.object instanceof he&&e.object.isPerspectiveCamera){const X=e.object.position;t.copy(X).sub(e.target);let ee=t.length();ee*=Math.tan(e.object.fov/2*Math.PI/180),se(2*s*ee/M.clientHeight,e.object.matrix),T(2*p*ee/M.clientHeight,e.object.matrix)}else M&&e.object instanceof me&&e.object.isOrthographicCamera?(se(s*(e.object.right-e.object.left)/e.object.zoom/M.clientWidth,e.object.matrix),T(p*(e.object.top-e.object.bottom)/e.object.zoom/M.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}})();function q(t){e.object instanceof he&&e.object.isPerspectiveCamera||e.object instanceof me&&e.object.isOrthographicCamera?S/=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function Q(t){e.object instanceof he&&e.object.isPerspectiveCamera||e.object instanceof me&&e.object.isOrthographicCamera?S*=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function re(t){if(!e.zoomToCursor||!e.domElement)return;y=!0;const n=e.domElement.getBoundingClientRect(),s=t.clientX-n.left,p=t.clientY-n.top,M=n.width,X=n.height;D.x=s/M*2-1,D.y=-(p/X)*2+1,G.set(D.x,D.y,1).unproject(e.object).sub(e.object.position).normalize()}function W(t){return Math.max(e.minDistance,Math.min(e.maxDistance,t))}function H(t){_.set(t.clientX,t.clientY)}function ce(t){re(t),L.set(t.clientX,t.clientY)}function te(t){A.set(t.clientX,t.clientY)}function xe(t){z.set(t.clientX,t.clientY),R.subVectors(z,_).multiplyScalar(e.rotateSpeed);const n=e.domElement;n&&(fe(2*Math.PI*R.x/n.clientHeight),x(2*Math.PI*R.y/n.clientHeight)),_.copy(z),e.update()}function Ce(t){g.set(t.clientX,t.clientY),u.subVectors(g,L),u.y>0?q(ie()):u.y<0&&Q(ie()),L.copy(g),e.update()}function J(t){N.set(t.clientX,t.clientY),k.subVectors(N,A).multiplyScalar(e.panSpeed),V(k.x,k.y),A.copy(N),e.update()}function we(t){re(t),t.deltaY<0?Q(ie()):t.deltaY>0&&q(ie()),e.update()}function O(t){let n=!1;switch(t.code){case e.keys.UP:V(0,e.keyPanSpeed),n=!0;break;case e.keys.BOTTOM:V(0,-e.keyPanSpeed),n=!0;break;case e.keys.LEFT:V(e.keyPanSpeed,0),n=!0;break;case e.keys.RIGHT:V(-e.keyPanSpeed,0),n=!0;break}n&&(t.preventDefault(),e.update())}function b(){if(m.length==1)_.set(m[0].pageX,m[0].pageY);else{const t=.5*(m[0].pageX+m[1].pageX),n=.5*(m[0].pageY+m[1].pageY);_.set(t,n)}}function U(){if(m.length==1)A.set(m[0].pageX,m[0].pageY);else{const t=.5*(m[0].pageX+m[1].pageX),n=.5*(m[0].pageY+m[1].pageY);A.set(t,n)}}function C(){const t=m[0].pageX-m[1].pageX,n=m[0].pageY-m[1].pageY,s=Math.sqrt(t*t+n*n);L.set(0,s)}function ne(){e.enableZoom&&C(),e.enablePan&&U()}function le(){e.enableZoom&&C(),e.enableRotate&&b()}function Te(t){if(m.length==1)z.set(t.pageX,t.pageY);else{const s=ze(t),p=.5*(t.pageX+s.x),M=.5*(t.pageY+s.y);z.set(p,M)}R.subVectors(z,_).multiplyScalar(e.rotateSpeed);const n=e.domElement;n&&(fe(2*Math.PI*R.x/n.clientHeight),x(2*Math.PI*R.y/n.clientHeight)),_.copy(z)}function Z(t){if(m.length==1)N.set(t.pageX,t.pageY);else{const n=ze(t),s=.5*(t.pageX+n.x),p=.5*(t.pageY+n.y);N.set(s,p)}k.subVectors(N,A).multiplyScalar(e.panSpeed),V(k.x,k.y),A.copy(N)}function pe(t){const n=ze(t),s=t.pageX-n.x,p=t.pageY-n.y,M=Math.sqrt(s*s+p*p);g.set(0,M),u.set(0,Math.pow(g.y/L.y,e.zoomSpeed)),q(u.y),L.copy(g)}function be(t){e.enableZoom&&pe(t),e.enablePan&&Z(t)}function Oe(t){e.enableZoom&&pe(t),e.enableRotate&&Te(t)}function je(t){var n,s;e.enabled!==!1&&(m.length===0&&((n=e.domElement)==null||n.ownerDocument.addEventListener("pointermove",ge),(s=e.domElement)==null||s.ownerDocument.addEventListener("pointerup",oe)),et(t),t.pointerType==="touch"?Qe(t):Ie(t))}function ge(t){e.enabled!==!1&&(t.pointerType==="touch"?Je(t):_e(t))}function oe(t){var n,s,p;tt(t),m.length===0&&((n=e.domElement)==null||n.releasePointerCapture(t.pointerId),(s=e.domElement)==null||s.ownerDocument.removeEventListener("pointermove",ge),(p=e.domElement)==null||p.ownerDocument.removeEventListener("pointerup",oe)),e.dispatchEvent(w),d=c.NONE}function Ie(t){let n;switch(t.button){case 0:n=e.mouseButtons.LEFT;break;case 1:n=e.mouseButtons.MIDDLE;break;case 2:n=e.mouseButtons.RIGHT;break;default:n=-1}switch(n){case ue.DOLLY:if(e.enableZoom===!1)return;ce(t),d=c.DOLLY;break;case ue.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(e.enablePan===!1)return;te(t),d=c.PAN}else{if(e.enableRotate===!1)return;H(t),d=c.ROTATE}break;case ue.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(e.enableRotate===!1)return;H(t),d=c.ROTATE}else{if(e.enablePan===!1)return;te(t),d=c.PAN}break;default:d=c.NONE}d!==c.NONE&&e.dispatchEvent(E)}function _e(t){if(e.enabled!==!1)switch(d){case c.ROTATE:if(e.enableRotate===!1)return;xe(t);break;case c.DOLLY:if(e.enableZoom===!1)return;Ce(t);break;case c.PAN:if(e.enablePan===!1)return;J(t);break}}function Ae(t){e.enabled===!1||e.enableZoom===!1||d!==c.NONE&&d!==c.ROTATE||(t.preventDefault(),e.dispatchEvent(E),we(t),e.dispatchEvent(w))}function Y(t){e.enabled===!1||e.enablePan===!1||O(t)}function Qe(t){switch(We(t),m.length){case 1:switch(e.touches.ONE){case de.ROTATE:if(e.enableRotate===!1)return;b(),d=c.TOUCH_ROTATE;break;case de.PAN:if(e.enablePan===!1)return;U(),d=c.TOUCH_PAN;break;default:d=c.NONE}break;case 2:switch(e.touches.TWO){case de.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;ne(),d=c.TOUCH_DOLLY_PAN;break;case de.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;le(),d=c.TOUCH_DOLLY_ROTATE;break;default:d=c.NONE}break;default:d=c.NONE}d!==c.NONE&&e.dispatchEvent(E)}function Je(t){switch(We(t),d){case c.TOUCH_ROTATE:if(e.enableRotate===!1)return;Te(t),e.update();break;case c.TOUCH_PAN:if(e.enablePan===!1)return;Z(t),e.update();break;case c.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;be(t),e.update();break;case c.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;Oe(t),e.update();break;default:d=c.NONE}}function Fe(t){e.enabled!==!1&&t.preventDefault()}function et(t){m.push(t)}function tt(t){delete v[t.pointerId];for(let n=0;n<m.length;n++)if(m[n].pointerId==t.pointerId){m.splice(n,1);return}}function We(t){let n=v[t.pointerId];n===void 0&&(n=new I,v[t.pointerId]=n),n.set(t.pageX,t.pageY)}function ze(t){const n=t.pointerId===m[0].pointerId?m[1]:m[0];return v[n.pointerId]}r!==void 0&&this.connect(r),this.update()}};const jt=h.forwardRef(({makeDefault:a,camera:o,regress:r,domElement:e,enableDamping:P=!0,keyEvents:E=!1,onChange:w,onStart:c,onEnd:d,...ae},l)=>{const f=B(u=>u.invalidate),S=B(u=>u.camera),F=B(u=>u.gl),_=B(u=>u.events),z=B(u=>u.setEvents),R=B(u=>u.set),A=B(u=>u.get),N=B(u=>u.performance),k=o||S,L=e||_.connected||F.domElement,g=h.useMemo(()=>new Mt(k),[k]);return Be(()=>{g.enabled&&g.update()},-1),h.useEffect(()=>(E&&g.connect(E===!0?L:E),g.connect(L),()=>void g.dispose()),[E,L,r,g,f]),h.useEffect(()=>{const u=y=>{f(),r&&N.regress(),w&&w(y)},G=y=>{c&&c(y)},D=y=>{d&&d(y)};return g.addEventListener("change",u),g.addEventListener("start",G),g.addEventListener("end",D),()=>{g.removeEventListener("start",G),g.removeEventListener("end",D),g.removeEventListener("change",u)}},[w,c,d,g,f,z]),h.useEffect(()=>{if(a){const u=A().controls;return R({controls:g}),()=>R({controls:u})}},[a,g]),h.createElement("primitive",Ge({ref:l,object:g,enableDamping:P},ae))});const At=()=>{const{progress:a}=yt();return Se(gt,{center:!0,children:ke("div",{className:"loader-container",children:[ke("div",{className:"circle-loader",children:[Se("div",{className:"circle"}),Se("div",{className:"circle"}),Se("div",{className:"circle"})]}),ke("p",{className:"loader-text",children:[a.toFixed(2),"%"]})]})})};export{At as L,jt as O};
